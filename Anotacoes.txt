def atualizar_historico_operacoes():
    import pandas as pd
    from sqlalchemy import text
    from backend.conexao import conectar  # importa a fun√ß√£o conectar

    engine = conectar()

    # ------------------------------
    # Leitura das tabelas
    # ------------------------------
    query_notas = "SELECT * FROM notas"
    query_precos = "SELECT * FROM historico_precos"
    query_proventos = "SELECT * FROM proventos"

    notas = pd.read_sql(query_notas, engine)
    precos = pd.read_sql(query_precos, engine)
    prov = pd.read_sql(query_proventos, engine)

    # Garantir formata√ß√£o de datas
    notas['data_registro'] = pd.to_datetime(notas['data_registro'], errors='coerce')
    precos['data_pregao'] = pd.to_datetime(precos['data_pregao'], errors='coerce')
    prov['data_com'] = pd.to_datetime(prov['data_com'], errors='coerce')

    # ------------------------------
    # Limpar tabela historico_operacoes
    # ------------------------------
    with engine.begin() as conn:
        conn.execute(text("DELETE FROM historico_operacoes"))

    # ------------------------------
    # Separar a√ß√µes e op√ß√µes
    # ------------------------------
    acoes = notas[notas['tipo_papel'] == 'ACAO']
    opcoes = notas[notas['tipo_papel'] == 'OPCAO']

    # ------------------------------
    # Quantidade comprada e vendida de a√ß√µes
    # ------------------------------
    compras = acoes[acoes['tipo_lado'] == 'C'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Quantidade_comprada=('quantidade', 'sum'),
        Total_compras=('valor_operacao', 'sum'),
        data_inicio=('data_registro', 'min')
    ).reset_index()

    # Fun√ß√£o para divis√£o segura
    def safe_div(num, den):
        return num / den if den != 0 else 0

    # Calculando pre√ßo m√©dio
    compras['preco_medio'] = compras.apply(
    lambda x: safe_div(x['Total_compras'], x['Quantidade_comprada']), axis=1
    )

    vendas = acoes[acoes['tipo_lado'] == 'V'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Quantidade_vendida=('quantidade', 'sum'),
        Total_vendas=('valor_operacao', 'sum')
    ).reset_index()

    # ------------------------------
    # Pr√™mios de op√ß√µes
    # ------------------------------
    premios_recebidos = opcoes[opcoes['tipo_lado'] == 'V'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Premios_recebidos=('valor_operacao', 'sum')
    ).reset_index()

    premios_pagos = opcoes[opcoes['tipo_lado'] == 'C'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Premios_pagos=('valor_operacao', 'sum')
    ).reset_index()

    # ------------------------------
    # Consolidar posi√ß√£o (a√ß√µes + clientes s√≥ de op√ß√µes)
    # ------------------------------
    consolidado = pd.merge(compras, vendas, on=['conta', 'cliente', 'ativo_base'], how='outer')
    consolidado = pd.merge(consolidado, premios_recebidos, on=['conta', 'cliente', 'ativo_base'], how='outer')
    consolidado = pd.merge(consolidado, premios_pagos, on=['conta', 'cliente', 'ativo_base'], how='outer')

    consolidado.fillna(0, inplace=True)

    # Quantidade atual e pr√™mio l√≠quido
    consolidado['quantidade_atual'] = consolidado['Quantidade_comprada'] - consolidado['Quantidade_vendida']
    consolidado['Premio_liquido'] = consolidado['Premios_recebidos'] - consolidado['Premios_pagos']

    # ------------------------------
    # Proventos por ativo e cliente (considerando hist√≥rico de compras)
    # ------------------------------
    proventos_total = []

    for _, row in consolidado.iterrows():
        conta = row['conta']
        cliente = row['cliente']
        ativo = row['ativo_base']
    
        # Seleciona todos os proventos desse ativo
        prov_ativo = prov[prov['ativo'] == ativo].copy()
        total_provento = 0
    
        for _, prov_row in prov_ativo.iterrows():
            data_com = prov_row['data_com']
        
            # Quantidade de a√ß√µes do cliente at√© a data do provento
            compras_anteriores = acoes[
                (acoes['conta'] == conta) &
                (acoes['cliente'] == cliente) &
                (acoes['ativo_base'] == ativo) &
                (acoes['data_registro'] <= data_com)
            ]['quantidade'].sum()
        
            # Provento recebido
            total_provento += compras_anteriores * prov_row['valor']
    
        proventos_total.append(total_provento)

    consolidado['Proventos'] = proventos_total

    # ------------------------------
    # Pre√ßos: fechamento mais recente e inicial
    # ------------------------------
    fechamento_recente = precos.sort_values('data_pregao').groupby('codigo_bdi').tail(1)
    fechamento_recente = fechamento_recente[['codigo_bdi', 'preco_fechamento']]

    datas_inicio = notas.groupby('ativo_base')['data_registro'].min().reset_index()
    datas_inicio = datas_inicio.rename(columns={'data_registro': 'primeira_data'})

    preco_inicio = pd.merge(datas_inicio, precos, left_on=['ativo_base', 'primeira_data'],
                            right_on=['codigo_bdi', 'data_pregao'], how='left')
    preco_inicio = preco_inicio[['ativo_base', 'preco_fechamento']].rename(
        columns={'preco_fechamento': 'preco_fechamento_inicio_operacoes'})

    # Merge dos pre√ßos
    consolidado = pd.merge(consolidado, fechamento_recente, left_on='ativo_base', right_on='codigo_bdi', how='left')
    consolidado = pd.merge(consolidado, preco_inicio, on='ativo_base', how='left')
    consolidado.rename(columns={'preco_fechamento': 'preco_fechamento'}, inplace=True)

    # ------------------------------
    # Tratamento de datas antes de enviar ao banco
    # ------------------------------
    consolidado['data_inicio'] = pd.to_datetime(consolidado['data_inicio'], errors='coerce')
    consolidado['data_inicio'] = consolidado['data_inicio'].dt.strftime('%Y-%m-%d %H:%M:%S')
    consolidado['data_inicio'] = consolidado['data_inicio'].where(pd.notnull(consolidado['data_inicio']), None)

    # ------------------------------
    # Calcular Rentabilidades (tratar divis√£o por zero)
    # ------------------------------
    def safe_div(num, den):
        return num / den if den != 0 else 0

    consolidado['Posicao_atual'] = consolidado['quantidade_atual'] * consolidado['preco_fechamento']
    # Investimento total baseado no pre√ßo m√©dio
    consolidado['investido'] = consolidado['quantidade_atual'] * consolidado['preco_medio']

    # Resultado sem considerar op√ß√µes
    consolidado['resultado_sem_opcoes'] = consolidado['Posicao_atual'] - consolidado['investido']

    # Resultado considerando op√ß√µes (pr√™mio l√≠quido)
    consolidado['resultado_com_opcoes'] = consolidado['Posicao_atual'] - consolidado['investido'] + consolidado['Premio_liquido']
    
    consolidado['Rentabilidade_sem_premio'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_premio'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Premio_liquido'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_proventos'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Proventos'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_proventos_premios'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Proventos'] + x['Premio_liquido'] - x['Total_compras'], x['Total_compras']), axis=1)

    consolidado['variacao_ativo'] = consolidado.apply(
        lambda x: safe_div(x['preco_fechamento'] - x['preco_fechamento_inicio_operacoes'], x['preco_fechamento_inicio_operacoes']), axis=1)

    # ------------------------------
    # Inserir no banco
    # ------------------------------
    consolidado.to_sql('historico_operacoes', engine, if_exists='append', index=False)
    print("Hist√≥rico de opera√ß√µes atualizado com sucesso!")

    
    
def atualizar_historico_operacoes():
    import pandas as pd
    from sqlalchemy import text
    from backend.conexao import conectar

    engine = conectar()

    # ------------------------------
    # Leitura das tabelas
    # ------------------------------
    notas = pd.read_sql("SELECT * FROM notas", engine)
    precos = pd.read_sql("SELECT * FROM historico_precos", engine)
    prov = pd.read_sql("SELECT * FROM proventos", engine)

    notas['data_registro'] = pd.to_datetime(notas['data_registro'], errors='coerce')
    precos['data_pregao'] = pd.to_datetime(precos['data_pregao'], errors='coerce')
    prov['data_com'] = pd.to_datetime(prov['data_com'], errors='coerce')

    # ------------------------------
    # Limpar hist√≥rico anterior
    # ------------------------------
    with engine.begin() as conn:
        conn.execute(text("DELETE FROM historico_operacoes"))

    # ------------------------------
    # Separar a√ß√µes e op√ß√µes
    # ------------------------------
    acoes = notas[notas['tipo_papel'] == 'ACAO']
    opcoes = notas[notas['tipo_papel'] == 'OPCAO']

    # ------------------------------
    # Quantidades e valores
    # ------------------------------
    compras = acoes[acoes['tipo_lado'] == 'C'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Quantidade_comprada=('quantidade', 'sum'),
        Total_compras=('valor_operacao', 'sum'),
        data_inicio=('data_registro', 'min')
    ).reset_index()

    # Pre√ßo m√©dio
    def safe_div(num, den):
        return num / den if den != 0 else 0

    compras['preco_medio'] = compras.apply(
        lambda x: safe_div(x['Total_compras'], x['Quantidade_comprada']), axis=1
    )

    vendas = acoes[acoes['tipo_lado'] == 'V'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Quantidade_vendida=('quantidade', 'sum'),
        Total_vendas=('valor_operacao', 'sum')
    ).reset_index()

    # Garantir data m√≠nima para cada ativo
    datas_todos_ativos = notas.groupby(['conta', 'cliente', 'ativo_base'])['data_registro'].min().reset_index()
    datas_todos_ativos.rename(columns={'data_registro': 'data_inicio'}, inplace=True)

    # ------------------------------
    # Pr√™mios de op√ß√µes
    # ------------------------------
    premios_recebidos = opcoes[opcoes['tipo_lado'] == 'V'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Premios_recebidos=('valor_operacao', 'sum')
    ).reset_index()

    premios_pagos = opcoes[opcoes['tipo_lado'] == 'C'].groupby(['conta', 'cliente', 'ativo_base']).agg(
        Premios_pagos=('valor_operacao', 'sum')
    ).reset_index()

    # ------------------------------
    # Consolidar dados
    # ------------------------------
    consolidado = pd.merge(datas_todos_ativos, compras, on=['conta', 'cliente', 'ativo_base'], how='left')
    consolidado = pd.merge(consolidado, vendas, on=['conta', 'cliente', 'ativo_base'], how='left')
    consolidado = pd.merge(consolidado, premios_recebidos, on=['conta', 'cliente', 'ativo_base'], how='left')
    consolidado = pd.merge(consolidado, premios_pagos, on=['conta', 'cliente', 'ativo_base'], how='left')

    # Corrigir colunas de data_inicio
    if 'data_inicio_x' in consolidado.columns and 'data_inicio_y' in consolidado.columns:
        consolidado['data_inicio'] = consolidado[['data_inicio_x', 'data_inicio_y']].min(axis=1)
        consolidado.drop(columns=['data_inicio_x', 'data_inicio_y'], inplace=True)
    elif 'data_inicio_x' in consolidado.columns:
        consolidado.rename(columns={'data_inicio_x': 'data_inicio'}, inplace=True)
    elif 'data_inicio_y' in consolidado.columns:
        consolidado.rename(columns={'data_inicio_y': 'data_inicio'}, inplace=True)

    consolidado.fillna({
        'Quantidade_comprada': 0,
        'Total_compras': 0,
        'Quantidade_vendida': 0,
        'Total_vendas': 0,
        'Premios_recebidos': 0,
        'Premios_pagos': 0,
        'preco_medio': 0
    }, inplace=True)

    # Quantidade e pr√™mios
    consolidado['quantidade_atual'] = consolidado['Quantidade_comprada'] - consolidado['Quantidade_vendida']
    consolidado['Premio_liquido'] = consolidado['Premios_recebidos'] - consolidado['Premios_pagos']

    # ------------------------------
    # Proventos
    # ------------------------------
    proventos_total = []
    for _, row in consolidado.iterrows():
        prov_ativo = prov[prov['ativo'] == row['ativo_base']]
        total_provento = 0
        for _, p in prov_ativo.iterrows():
            qtd_ate_data = acoes[
                (acoes['conta'] == row['conta']) &
                (acoes['cliente'] == row['cliente']) &
                (acoes['ativo_base'] == row['ativo_base']) &
                (acoes['data_registro'] <= p['data_com'])
            ]['quantidade'].sum()
            total_provento += qtd_ate_data * p['valor']
        proventos_total.append(total_provento)

    consolidado['Proventos'] = proventos_total

    # ------------------------------
    # Pre√ßos
    # ------------------------------
    #fechamento_recente = precos.sort_values('data_pregao').groupby('codigo_bdi').tail(1)
   # fechamento_recente = fechamento_recente[['codigo_bdi', 'preco_fechamento']]

   ############
   
   # Mesclar apenas ativo_base com preco_atual
    ativos_yahoo = pd.read_sql("SELECT asset_original, preco_atual FROM ativos_yahoo", engine)
    consolidado = pd.merge(
        consolidado,
        ativos_yahoo[['asset_original', 'preco_atual']],
        left_on='ativo_base',
        right_on='asset_original',
        how='left'
    )

    # Preencher preco_fechamento com preco_atual e remover colunas extras
    consolidado['preco_fechamento'] = consolidado['preco_atual'].fillna(0)
    consolidado.drop(columns=['asset_original', 'preco_atual'], inplace=True)

    ##################

    preco_inicio = pd.merge(
        notas.groupby('ativo_base')['data_registro'].min().reset_index(),
        precos, left_on=['ativo_base', 'data_registro'], right_on=['codigo_bdi', 'data_pregao'], how='left'
    )[['ativo_base', 'preco_fechamento']].rename(columns={'preco_fechamento': 'preco_fechamento_inicio_operacoes'})

    #consolidado = pd.merge(consolidado, left_on='ativo_base', right_on='codigo_bdi', how='left')
    #consolidado = pd.merge(consolidado, precos, left_on='ativo_base', right_on='codigo_bdi', how='left')
    consolidado = pd.merge(consolidado, preco_inicio, on='ativo_base', how='left')
    consolidado.rename(columns={'preco_fechamento': 'preco_fechamento'}, inplace=True)

    # ------------------------------
    # C√°lculos finais e rentabilidades
    # ------------------------------
    consolidado['Posicao_atual'] = consolidado['quantidade_atual'] * consolidado['preco_fechamento']
    consolidado['investido'] = consolidado['quantidade_atual'] * consolidado['preco_medio']

    consolidado['resultado_sem_opcoes'] = consolidado['Posicao_atual'] - consolidado['investido']
    consolidado['resultado_com_opcoes'] = consolidado['resultado_sem_opcoes'] + consolidado['Premio_liquido']
    
    consolidado['Rentabilidade_sem_premio'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_premio'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Premio_liquido'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_proventos'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Proventos'] - x['Total_compras'], x['Total_compras']), axis=1)
    consolidado['Rentabilidade_com_proventos_premios'] = consolidado.apply(
        lambda x: safe_div(x['Total_vendas'] + x['Posicao_atual'] + x['Proventos'] + x['Premio_liquido'] - x['Total_compras'], x['Total_compras']), axis=1)

    consolidado['variacao_ativo'] = consolidado.apply(
        lambda x: safe_div(x['preco_fechamento'] - x['preco_fechamento_inicio_operacoes'], x['preco_fechamento_inicio_operacoes']), axis=1)

    # ------------------------------
    # Salvar no banco
    # ------------------------------
    consolidado.to_sql('historico_operacoes', engine, if_exists='append', index=False)
    print("Hist√≥rico de opera√ß√µes atualizado com sucesso!")



    Dash de consulta de Premios 

    import streamlit as st
import pandas as pd
from importacao import (
    obter_lista_assets,
    obter_preco_ultimo,
    atualizar_preco,
    engine
)
from frontend.auth import require_usuario

def render():
    # üîí Verifica login e perfil
    require_usuario()
    usuario = st.session_state.usuario

    # -----------------------------
    # ATUALIZA√á√ÉO DE PRE√áOS
    # -----------------------------
    st.title("üéØ Consulta de Pr√™mios")
    st.write("Aqui voc√™ pode atualizar os pre√ßos dos ativos cadastrados.")

    if st.button("üîÑ Atualizar todos os pre√ßos"):
        df_assets = obter_lista_assets(engine)
        atualizados = 0
        falhas = []

        progress_bar = st.progress(0)
        status_text = st.empty()

        for i, row in df_assets.iterrows():
            ticker_yahoo = row['asset_original'].strip().upper() + ".SA"
            status_text.text(f"üîç Atualizando {row['asset_original']}...")
            preco = obter_preco_ultimo(ticker_yahoo)

            if preco is not None:
                atualizar_preco(engine, row['asset_original'], preco)
                atualizados += 1
            else:
                falhas.append(row['asset_original'])

            progress_bar.progress((i + 1) / len(df_assets))

        st.success(f"‚úÖ {atualizados} ativos atualizados com sucesso.")
        if falhas:
            st.warning(f"‚ö†Ô∏è Falha ao atualizar os seguintes ativos: {', '.join(falhas)}")

    # -----------------------------
    # DASH DE CONSULTA
    # -----------------------------
    st.title("Consulta de Opera√ß√µes Consolidadas")
    st.markdown("Filtre por cliente, ativo e per√≠odo para visualizar o hist√≥rico de opera√ß√µes.")

    col1, col2, col3, col4, col5, col6 = st.columns(6)

    with col1:
        cliente_input = st.text_input("Digite o nome do cliente:")

    with col2:
        try:
            ativos = pd.read_sql("SELECT DISTINCT ativo_base FROM historico_operacoes", engine)
            ativo_selecionado = st.selectbox("Selecione o ativo (opcional):", ["Todos"] + ativos['ativo_base'].tolist())
        except Exception:
            ativo_selecionado = "Todos"

        anos_disponiveis = pd.read_sql(
            "SELECT DISTINCT YEAR(data_registro) AS ano FROM notas ORDER BY ano DESC",
            engine
        )

    with col3:
        ano_selecionado = st.selectbox("Selecione o ano:", anos_disponiveis['ano'].tolist())

    with col4:
        data_inicio = st.date_input("Data inicial")

    with col5:
        data_fim = st.date_input("Data final")

    with col6:
        tipo_posicao = st.selectbox(
            "Tipo de posi√ß√£o:",
            ["Todas", "Ativas (quantidade > 0)", "Zeradas (quantidade <= 0)"]
        )

    if st.button("Filtrar Opera√ß√µes"):
        query = """
        SELECT 
            data_inicio, conta, cliente, ativo_base, quantidade_atual, preco_medio, 
            preco_fechamento, investido, Posicao_atual, resultado_sem_opcoes,Premio_liquido, resultado_com_opcoes
        FROM historico_operacoes
        WHERE 1=1
        """
        params = []

        if cliente_input.strip() != "":
            query += " AND cliente LIKE %s"
            params.append(f"%{cliente_input.strip()}%")

        if ativo_selecionado != "Todos":
            query += " AND ativo_base = %s"
            params.append(ativo_selecionado)

        if data_inicio:
            query += " AND data_inicio >= %s"
            params.append(data_inicio)
        if data_fim:
            query += " AND data_inicio <= %s"
            params.append(data_fim)

        if tipo_posicao == "Ativas (quantidade > 0)":
            query += " AND quantidade_atual > 0"
        elif tipo_posicao == "Zeradas (quantidade <= 0)":
            query += " AND quantidade_atual <= 0"

        query += " ORDER BY cliente, ativo_base"

        try:
            df_consulta = pd.read_sql(query, engine, params=tuple(params))

            if not df_consulta.empty:
                soma_premio = df_consulta['Premio_liquido'].sum()
                st.metric(label="Total de Pr√™mio Recebido", value=f"R$ {soma_premio:,.2f}")
            else:
                st.warning("Nenhum dado encontrado para calcular o Pr√™mio L√≠quido.")

            colunas_moeda = [
                'preco_medio', 'preco_fechamento', 'investido', 'Posicao_atual',
                'resultado_sem_opcoes', 'Premio_liquido', 'resultado_com_opcoes'
            ]

            for coluna in colunas_moeda:
                if coluna in df_consulta.columns:
                    df_consulta[coluna] = df_consulta[coluna].apply(
                        lambda x: f"R$ {x:,.2f}" if pd.notnull(x) else "R$ 0,00"
                    )

            df_consulta = df_consulta.rename(columns={
                "data_inicio": "Data de Inicio",
                "conta": "Conta",
                "cliente": "Cliente",
                "ativo_base": "Ativo",
                "quantidade_atual": "Quantidade Atual",
                "preco_medio": "Pre√ßo M√©dio",
                "preco_fechamento": "Pre√ßo Atual",
                "investido": "Valor Investido",
                "Posicao_atual": "Posi√ß√£o Atual",
                "resultado_sem_opcoes": "Resultado sem Op√ß√µes",
                "Premio_liquido": "Pr√™mios Recebidos",
                "resultado_com_opcoes": "Resultado com Op√ß√µes"
            })

            st.dataframe(df_consulta, use_container_width=True)
            st.success(f"{len(df_consulta)} registros encontrados.")

            # -----------------------------
            # DASH DE RESUMO MENSAL
            # -----------------------------
            st.title("Pr√™mio Mensal")

            query_resumo = """
            SELECT 
                cliente,
                MONTH(data_registro) AS mes,
                SUM(
                    CASE 
                        WHEN tipo_lado = 'V' THEN valor_operacao
                        WHEN tipo_lado = 'C' THEN -valor_operacao
                        ELSE 0
                    END
                ) AS premio_total
            FROM notas
            WHERE 
                YEAR(data_registro) = %s
                AND tipo_papel = 'OPCAO'
            """
            params = [ano_selecionado]

            if cliente_input.strip() != "":
                query_resumo += " AND cliente LIKE %s"
                params.append(f"%{cliente_input.strip()}%")

            query_resumo += " GROUP BY cliente, mes ORDER BY cliente, mes"

            df_resumo = pd.read_sql(query_resumo, engine, params=tuple(params))

            mes_abreviado = {
                1: 'Jan', 2: 'Fev', 3: 'Mar', 4: 'Abr',
                5: 'Mai', 6: 'Jun', 7: 'Jul', 8: 'Ago',
                9: 'Set', 10: 'Out', 11: 'Nov', 12: 'Dez'
            }
            df_resumo['mes'] = df_resumo['mes'].apply(lambda m: f"{mes_abreviado[m]}-{ano_selecionado}")
            ordem_meses = [f"{mes_abreviado[m]}-{ano_selecionado}" for m in range(1, 13)]
            df_resumo['mes'] = pd.Categorical(df_resumo['mes'], categories=ordem_meses, ordered=True)

            df_pivot = df_resumo.pivot(index='cliente', columns='mes', values='premio_total').fillna(0)
            df_pivot = df_pivot.sort_index()
            df_pivot_formatado = df_pivot.applymap(lambda x: f"R$ {x:,.2f}")

            st.subheader(f"Pr√™mio Recebido - Ano {ano_selecionado}")
            st.dataframe(df_pivot_formatado)

        except Exception as e:
            st.error(f"‚ùå Erro ao consultar: {e}")